# ReactChildrenç†è§£ jieforEach, map, count, toArray, only

è¿™æ˜¯reactå†…ç½®çš„ä¸€äº›éå†æ–¹æ³•ï¼Œå…¨éƒ¨æŒ‚è½½åœ¨React.Childrenä¸‹è¾¹,ä¸‹è¾¹æœ‰å¸¸è§„ç”¨æ³•ï¼Œä¸»è¦ç”¨æ¥éå†ç»„ä»¶ä¼ å…¥çš„å­ç»„ä»¶
```
React.Children.map(this.props.children, function (child) {
  return <li>{child}</li>;
})
```
æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ä¸»è¦çš„å®ç°

1. forEach

```javascript
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  const traverseContext = getPooledTraverseContext(
    null,
    null,
    forEachFunc,
    forEachContext,
  );
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}
```

æˆ‘ä»¬çœ‹ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•å¦‚æœä¸ºç©ºå°±ç›´æ¥è¿”å›nullï¼Œç”¨åˆ°äº†ä¸€ä¸ª**getPooledTraverseContext**æ–¹æ³•ï¼Œè¿™é‡Œå€Ÿç”¨äº†æ•°æ®åº“è¿æ¥æ± çš„æ€æƒ³åœ¨å…¶ä»–ä¸€äº›åº“ä¸­æˆ‘ä»¬ä¹Ÿå¯ä»¥çœ‹åˆ°ï¼Œè¿™æ ·å¯ä»¥å‡å°‘é¢‘ç¹åˆ›å»ºå¯¹è±¡å¸¦æ¥çš„å¼€é”€ï¼ŒåŒæ—¶ä¹Ÿçœå»äº†åƒåœ¾å›æ”¶æ¶ˆè€—
åœ¨æ–‡ä»¶æœ€å¼€å§‹å®šä¹‰äº†2ä¸ªå˜é‡`const POOL_SIZE = 10;const traverseContextPool = [];`ä¸€ä¸ªæ˜¯è¿æ¥æ± çš„æ•°é‡ï¼Œä¸€ä¸ªç”¨æ¥å­˜æ”¾è¿æ¥æ± 
```
function getPooledTraverseContext(
  mapResult,
  keyPrefix,
  mapFunction,
  mapContext,
) {
  if (traverseContextPool.length) {
    const traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0,
    };
  }
}
```

ä»æ–¹æ³•å®šä¹‰æˆ‘ä»¬å¯ä»¥çœ‹å‡ºå½“è¿æ¥æ± çš„æ•°é‡å¤§äº0çš„æ—¶å€™æˆ‘ä»¬ç›´æ¥å–å‡ºä¸€ä¸ªå¯¹è±¡å¹¶ä¸”èµ‹å€¼ç»™ä¼ å…¥çš„å‚æ•°ä½¿ç”¨ï¼Œå¦‚æœåˆšå¥½ä¸º0æ‰åˆ›å»ºæ–°çš„å¯¹è±¡
`releaseTraverseContext`ç”¨æ¥é‡ç½®è¿æ¥æ± å¯¹è±¡å±æ€§å¹¶è¡¥å›è¿æ¥æ± ä»¥æä¾›ä¹‹åä½¿ç”¨
æœ€åå†æ¥çœ‹æœ€æ ¸å¿ƒçš„éå†ä»£ç `traverseAllChildrenå®é™…ä¸Šå°±æ˜¯traverseAllChildrenImpl`ä»£ç æ¯”è¾ƒå¤šå°±è´´å‡ºæ ¸å¿ƒä»£ç çœ‹ä¸€ä¸‹
ä¸»è¦æ˜¯å…ˆå¯¹childrenè¿›è¡Œäº†ç±»å‹æ£€éªŒå¦‚æœstringï¼Œobject,numberè¯æ˜æ˜¯åªæœ‰ä¸€ä¸ªå­ç»„ä»¶ï¼Œæ•°ç»„è¯´æ˜æœ‰å¤šä¸ªç»„ä»¶ï¼Œç”±äºé€’å½’çš„è°ƒç”¨æœ€ç»ˆéƒ½ä¼šè¿›å…¥åªæœ‰ä¸€ä¸ªå­ç»„ä»¶çš„çŠ¶æ€ï¼Œæ‰§è¡Œcallbackæ–¹æ³•é¡ºä¾¿è®¡ç®—æ‰€æœ‰ç»„ä»¶çš„æ•°é‡
```

if (invokeCallback) { // æ‰§è¡Œä¼ å…¥çš„callbackæ–¹æ³•
  callback(
    traverseContext,
    children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,
  );
  return 1; // å‰è¾¹æœ‰ç±»å‹åˆ¤æ–­å¦‚æœåªæœ‰ä¸€ä¸ªå­ç»„ä»¶ç›´æ¥è¿”å›1
}
if (Array.isArray(children)) { // å½“childrenä¸ºæ•°ç»„æ—¶
  for (let i = 0; i < children.length; i++) {
    child = children[i];
    nextName = nextNamePrefix + getComponentKey(child, i);
    subtreeCount += traverseAllChildrenImpl( // é€’å½’çš„æ‰§è¡Œæ¯ä¸€ä¸ªå­ç»„ä»¶
      child,
      nextName,
      callback,
      traverseContext,
    );
  }
} else { // å½“childrenä¸ºå¯è¿­ä»£çš„å¯¹è±¡æ—¶
  const iteratorFn = getIteratorFn(children);
  if (typeof iteratorFn === 'function') { // åˆ¤æ–­æ˜¯å¦ğŸ‰‘ï¸è¿­ä»£
    if (__DEV__) {
      // Warn about using Maps as children
      if (iteratorFn === children.entries) {
        warning(
          didWarnAboutMaps,
          'Using Maps as children is unsupported and will likely yield ' +
            'unexpected results. Convert it to a sequence/iterable of keyed ' +
            'ReactElements instead.',
        );
        didWarnAboutMaps = true;
      }
    }

    const iterator = iteratorFn.call(children);
    let step;
    let ii = 0;
    while (!(step = iterator.next()).done) {
      child = step.value;
      nextName = nextNamePrefix + getComponentKey(child, ii++);
      subtreeCount += traverseAllChildrenImpl(
        child,
        nextName,
        callback,
        traverseContext,
      );
    }
  } else if (type === 'object') {
    let addendum = '';
    if (__DEV__) {
      addendum =
        ' If you meant to render a collection of children, use an array ' +
        'instead.' +
        ReactDebugCurrentFrame.getStackAddendum();
    }
    const childrenString = '' + children;
    invariant(
      false,
      'Objects are not valid as a React child (found: %s).%s',
      childrenString === '[object Object]'
        ? 'object with keys {' + Object.keys(children).join(', ') + '}'
        : childrenString,
      addendum,
    );
  }
}
return subtreeCount; // æœ€åè¿”å›æ‰€æœ‰å­ç»„ä»¶çš„æ•°é‡
```

2. count
ä»ä¸Šè¾¹çš„åˆ†æä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å·²ç»ç®—å‡ºäº†æ•°é‡æ‰€æœ‰countå’ŒforEachçš„åŒºåˆ«å°±åœ¨æ˜¯å¦è¿”å›äº†`traverseAllChildren`æ–¹æ³•

3. map

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ‰§è¡Œçš„æµç¨‹åŸºæœ¬ç›¸åŒå°±æ˜¯`traverseAllChildren`ä¼ å…¥çš„callbackæ–¹æ³•ï¼Œäº‹ç‰©æ± å¯¹è±¡çš„å‚æ•°ä¸åŒ
```
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  const result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context); // éå†æ‰§è¡Œå¹¶å¯¹resultæ·»åŠ funcæ¸²æŸ“å‡ºçš„ç»„ä»¶
  return result;
}
function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  let escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  const traverseContext = getPooledTraverseContext(
    array,
    escapedPrefix,
    func,
    context,
  );
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext); // è¿™é‡Œæ˜¯æœ€å…³é”®çš„ä¸€å¥æ‰€æœ‰è°ƒç”¨éƒ½åœ¨è¿™é‡Œ
  releaseTraverseContext(traverseContext);
}
function mapSingleChildIntoContext(bookKeeping, child, childKey) { // åŒæ ·ä¹Ÿæ˜¯åˆ¤æ–­ç±»å‹æ•°ç»„é€’å½’çš„å¤„ç†ï¼Œæœ€åè®²æ‰€æœ‰éƒ½pushè¿›resultæ•°ç»„é‡Œ
  const {result, keyPrefix, func, context} = bookKeeping;
  let mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c => c);
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(
        mappedChild,
        // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        keyPrefix +
          (mappedChild.key && (!child || child.key !== mappedChild.key)
            ? escapeUserProvidedKey(mappedChild.key) + '/'
            : '') +
          childKey,
      );
    }
    result.push(mappedChild);
  }
}
```

è¿™é‡Œä¸»è¦çš„å‡ ä¸ªapiéƒ½å·²ç»åˆ†æå®Œäº†ï¼Œå‰©ä¸‹çš„toArray, onlyåŸç†åŸºæœ¬ä¸€æ ·ï¼Œå°±ä¸ä¸€ä¸€è¯´æ˜äº†
