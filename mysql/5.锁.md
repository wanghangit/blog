# 锁

在处理数据并发的情况会遇到多个线程同时修改数据库的情况，这时候为了保持数据的一致性就要用到锁的概念了，锁一共有3种

1. 全局锁
全局加读锁`Flush tables with read lock`让数据库处于只读状态所有的更新都会被阻塞，如果不加锁出现问题，
会导致数据不一致，这就要用到事务，mysql默认的引擎不支持事务，所以会有这种级别的锁出现

2. 表级锁

- 表锁
语句`lock tables t1 read, t2 write`,这样在unlock之前所有的读t1,和t2都会被阻塞
- 元数据锁（MDL）
在访问一个表的时候会默认加上锁，读锁之间不互斥，读写锁，和写锁之间互斥
- 应用
给一个小表加字段
如果我们需要加一个字段，但请求比较频繁，一直有事务在执行，这时候我们就不能给表加字段
建议给`alter table`语句加上等待时间，如果拿到写锁最好，拿不到也不会阻塞后边执行的语句，反复执行这个语句直到成功

3. 行锁

- 两阶段锁
比如有2个事务来更新一行数据，在A事务执行完后不会立马释放锁，而是要到事务commit后才会释放锁，B事务才能执行，执行顺序很重要，使用比较频繁的行数据最后考后执行，来减少锁的阻塞时间

- 死锁和死锁检测
当两个事务出现相互依赖的情况，会造成死锁，双方都在等对方释放资源，进入了死锁状态，一般有两种策略
一种是设置超时时间innodb_lock_wait_timeout
一种是发起死锁检测将参数 innodb_deadlock_detect 设置为 on
死锁检测相当消耗内存，因为要遍历检测，可以通过从一行改成多行减少锁的冲突
